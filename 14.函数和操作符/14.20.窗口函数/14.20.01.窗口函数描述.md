### 14.20.1 窗口函数描述

本节描述了非聚合窗口函数，这些函数针对查询中的每一行，使用与该行相关的多行数据进行计算。  
大多数聚合函数也可以作为窗口函数使用；请参见第14.19.1节“聚合函数描述”。

关于窗口函数的使用信息和示例，以及 `OVER` 子句、窗口、分区、帧、同组（peer）等术语的定义，请参见第14.20.2节“窗口函数概念与语法”。

表 14.30 窗口函数

| 名称             | 描述                           |
| ---------------- | ------------------------------ |
| `CUME_DIST()`    | 累积分布值                     |
| `DENSE_RANK()`   | 当前行在分区内的排名（无间隔） |
| `FIRST_VALUE()`  | 窗口帧中第一行的参数值         |
| `LAG()`          | 当前行在分区内前N行的参数值    |
| `LAST_VALUE()`   | 窗口帧中最后一行的参数值       |
| `LEAD()`         | 当前行在分区内后N行的参数值    |
| `NTH_VALUE()`    | 窗口帧中第N行的参数值          |
| `NTILE()`        | 当前行在分区内的桶编号         |
| `PERCENT_RANK()` | 百分比排名值                   |
| `RANK()`         | 当前行在分区内的排名（有间隔） |
| `ROW_NUMBER()`   | 当前行在分区内的行号           |

在下面的函数描述中，`over_clause` 表示 `OVER` 子句，详见第14.20.2节“窗口函数概念与语法”。  
部分窗口函数允许使用 `null_treatment` 子句，指定计算结果时如何处理 `NULL` 值。该子句是可选的，属于SQL标准的一部分，但MySQL仅支持 `RESPECT NULLS`（也是默认值），即在计算结果时考虑 `NULL` 值。虽然 `IGNORE NULLS` 可以解析，但会产生错误。

---

#### `CUME_DIST()` over_clause

返回当前行在组内的累积分布值，即分区内小于或等于当前行值的行数除以分区总行数。返回值范围在0到1之间。

通常应结合 `ORDER BY` 使用，以便按所需顺序对分区内行进行排序。如果不使用 `ORDER BY`，则所有行视为同组（peer），值为 N/N = 1，其中N是分区大小。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。

以下查询展示了对 `val` 列中的值，分别使用 `CUME_DIST()` 和类似的 `PERCENT_RANK()` 计算结果，同时显示行号（使用 `ROW_NUMBER()`）：

mysql> SELECT
         val,
         ROW_NUMBER()   OVER w AS 'row_number',
         CUME_DIST()    OVER w AS 'cume_dist',
         PERCENT_RANK() OVER w AS 'percent_rank'
       FROM numbers
       WINDOW w AS (ORDER BY val);

---

#### `DENSE_RANK()` over_clause

返回当前行在分区中的排名，不产生间隔。  
同组（peer）行被认为是平局，获得相同排名。  
此函数为同组分配连续的排名，结果是如果存在大于一行的组，也不会出现不连续的排名数字。

通常应结合 `ORDER BY` 使用。如果不使用 `ORDER BY`，所有行视为同组。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。

---

#### `FIRST_VALUE(expr) [null_treatment] over_clause`

返回窗口帧中第一行的 `expr` 参数的值。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。`null_treatment` 如本节开头所述。

以下查询演示了 `FIRST_VALUE()`、`LAST_VALUE()` 和两个不同的 `NTH_VALUE()` 调用：

mysql> SELECT
         time, subject, val,
         FIRST_VALUE(val)  OVER w AS 'first',
         LAST_VALUE(val)   OVER w AS 'last',
         NTH_VALUE(val, 2) OVER w AS 'second',
         NTH_VALUE(val, 4) OVER w AS 'fourth'
       FROM observations
       WINDOW w AS (PARTITION BY subject ORDER BY time
                    ROWS UNBOUNDED PRECEDING);

每个函数使用当前帧内的行，如窗口定义所示，从分区的第一行到当前行。对于 `NTH_VALUE()` 调用，当前帧有时不包含请求的行，此时返回值为 `NULL`。

---

#### `LAG(expr [, N[, default]]) [null_treatment] over_clause`

返回分区内当前行之前第 `N` 行的 `expr` 参数值。如果不存在这样的行，则返回 `default`。  
例如，如果 `N` 是3，则对前3行返回 `default`。如果省略 `N` 或 `default`，默认值分别为1和 `NULL`。

`N` 必须是一个字面量非负整数。如果 `N` 为0，则对当前行计算 `expr`。

从MySQL 8.0.22开始，`N` 不能为 `NULL`，且必须是0到2⁶³范围内的整数，且可以是以下任一形式：
- 无符号整数常量
- 位置参数标记（`?`）
- 用户定义变量
- 存储过程中的局部变量

`over_clause` 详见第14.20.2节“窗口函数概念与语法”，`null_treatment` 如本节开头所述。

`LAG()`（以及类似的 `LEAD()` 函数）通常用于计算行之间的差异。  
以下查询展示了按时间排序的观测值，并使用 `LAG()` 和 `LEAD()` 计算相邻行之间的差异：

mysql> SELECT
         t, val,
         LAG(val)        OVER w AS 'lag',
         LEAD(val)       OVER w AS 'lead',
         val - LAG(val)  OVER w AS 'lag diff',
         val - LEAD(val) OVER w AS 'lead diff'
       FROM series
       WINDOW w AS (ORDER BY t);

在示例中，`LAG()` 和 `LEAD()` 使用默认的 `N=1` 和 `default=NULL`。  
第一行由于没有前一行，`LAG()` 返回默认值 `NULL`；最后一行由于没有后一行，`LEAD()` 返回默认值 `NULL`。

`LAG()` 和 `LEAD()` 也可以用于求和，例如基于斐波那契数列的数据集：

mysql> SELECT n FROM fib ORDER BY n;

以下查询使用 `LAG()` 和 `LEAD()` 计算斐波那契数列的下一项和下下项：

mysql> SELECT
         n,
         LAG(n, 1, 0)      OVER w AS 'lag',
         LEAD(n, 1, 0)     OVER w AS 'lead',
         n + LAG(n, 1, 0)  OVER w AS 'next_n',
         n + LEAD(n, 1, 0) OVER w AS 'next_next_n'
       FROM fib
       WINDOW w AS (ORDER BY n);

从MySQL 8.0.22起，不允许在此函数中使用负数作为行偏移量。

---

#### `LAST_VALUE(expr) [null_treatment] over_clause`

返回窗口帧中最后一行的 `expr` 参数值。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”，`null_treatment` 如本节开头所述。

示例请参见 `FIRST_VALUE()` 函数描述。

---

#### `LEAD(expr [, N[, default]]) [null_treatment] over_clause`

返回分区内当前行之后第 `N` 行的 `expr` 参数值。如果不存在这样的行，则返回 `default`。  
例如，如果 `N` 是3，则对最后三行返回 `default`。如果省略 `N` 或 `default`，默认值分别为1和 `NULL`。

`N` 必须是一个字面量非负整数。如果 `N` 为0，则对当前行计算 `expr`。

从MySQL 8.0.22开始，`N` 不能为 `NULL`，且必须是0到2⁶³范围内的整数，且可以是以下任一形式：
- 无符号整数常量
- 位置参数标记（`?`）
- 用户定义变量
- 存储过程中的局部变量

`over_clause` 详见第14.20.2节“窗口函数概念与语法”，`null_treatment` 如本节开头所述。

示例请参见 `LAG()` 函数描述。

从MySQL 8.0.22起，不能使用负数作为行偏移量。

---

#### `NTH_VALUE(expr, N) [from_first_last] [null_treatment] over_clause`

返回窗口帧中第 `N` 行的 `expr` 参数值。如果不存在这样的行，返回 `NULL`。

`N` 必须是一个字面量正整数。

`from_first_last` 是SQL标准的一部分，但MySQL仅支持 `FROM FIRST`（也是默认值），即从窗口的第一行开始计算。  
`FROM LAST` 虽然可以解析，但会导致错误。要获得与 `FROM LAST` 相同的效果，请使用 `ORDER BY` 反向排序。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”，`null_treatment` 如本节开头所述。

示例请参见 `FIRST_VALUE()` 函数描述。

从MySQL 8.0.22起，不允许将 `NULL` 用作行参数。

---

#### `NTILE(N) over_clause`

将一个分区划分为 `N` 组（桶），并为分区中的每一行分配一个桶编号，返回当前行所属的桶编号。  
例如，如果 `N` 是4，`NTILE()` 将行分为4组；如果是100，则分为100组。

`N` 必须是一个字面量正整数。返回的桶编号范围是1到N。

从MySQL 8.0.22开始，`N` 不能为 `NULL`，且必须是0到2⁶³范围内的整数，且可以是以下任一形式：
- 无符号整数常量
- 位置参数标记（`?`）
- 用户定义变量
- 存储过程中的局部变量

通常应结合 `ORDER BY` 使用，以便按所需顺序对分区内行进行排序。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。

以下查询展示了对 `val` 列的值进行2组和4组划分，同时显示行号（使用 `ROW_NUMBER()`）：

mysql> SELECT
         val,
         ROW_NUMBER() OVER w AS 'row_number',
         NTILE(2)     OVER w AS 'ntile2',
         NTILE(4)     OVER w AS 'ntile4'
       FROM numbers
       WINDOW w AS (ORDER BY val);

从MySQL 8.0.22起，不再允许使用 `NTILE(NULL)`。

---

#### `PERCENT_RANK() over_clause`

返回分区内小于当前行值的行数所占百分比，不包含最大值。  
返回值范围从0到1，按以下公式计算，相对排名：

(rank - 1) / (rows - 1)

其中，`rank` 是行排名，`rows` 是分区行数。

通常应结合 `ORDER BY` 使用。如果不使用 `ORDER BY`，所有行视为同组。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。

示例请参见 `CUME_DIST()` 函数描述。

---

#### `RANK() over_clause`

返回当前行在分区内的排名，存在间隔。  
同组（peer）行被认为是平局，获得相同排名。  
如果存在多个同组行，则下一个较大值的排名会增加同组数量减一的间隔，因此排名数字是不连续的。

通常应结合 `ORDER BY` 使用。如果不使用 `ORDER BY`，所有行视为同组。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。

以下查询展示了 `RANK()` 和 `DENSE_RANK()` 之间的区别。查询显示了 `val` 列中值的排名，包括重复值：

mysql> SELECT
         val,
         ROW_NUMBER() OVER w AS 'row_number',
         RANK()       OVER w AS 'rank',
         DENSE_RANK() OVER w AS 'dense_rank'
       FROM numbers
       WINDOW w AS (ORDER BY val);

---

#### `ROW_NUMBER() over_clause`

返回当前行在分区内的行号。行号从1到分区行数。

`ORDER BY` 会影响行号的分配顺序。如果不使用 `ORDER BY`，行号顺序是不确定的。

`ROW_NUMBER()` 为同组行分配不同的行号。  
如果希望同组行分配相同的值，请使用 `RANK()` 或 `DENSE_RANK()`。示例请参见 `RANK()` 函数描述。

`over_clause` 详见第14.20.2节“窗口函数概念与语法”。