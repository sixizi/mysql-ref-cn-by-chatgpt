# **13.5 JSON 数据类型**







## **目录**





- [创建 JSON 值](#创建-json-值)
- [JSON 值的规范化、合并和自动封装](#json-值的规范化合并和自动封装)
- [搜索与修改 JSON 值](#搜索与修改-json-值)
- [JSON 路径语法](#json-路径语法)
- [JSON 值的比较与排序](#json-值的比较与排序)
- [JSON 与非 JSON 值之间的转换](#json-与非-json-值之间的转换)
- [JSON 值的聚合](#json-值的聚合)





------



MySQL 支持符合 [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259) 定义的原生 JSON（JavaScript Object Notation）数据类型，可高效访问 JSON 文档中的数据。

相比将 JSON 格式字符串存储在字符串列中，JSON 数据类型具有以下优势：



1. **自动验证**

   存储在 JSON 列中的 JSON 文档会自动验证，**无效文档会产生错误**。

2. **优化存储格式**

   JSON 文档会被转换成内部二进制格式，便于快速读取元素。

   

   - 无需从文本解析
   - 可直接按 **键** 或 **数组索引** 定位子对象或嵌套值，而无需读取整个文档

   





MySQL 还支持 [**RFC 7396**](https://datatracker.ietf.org/doc/html/rfc7396) 定义的 JSON Merge Patch 格式，通过 JSON_MERGE_PATCH() 函数实现。详细示例见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。



> **注意**

> 在本节中，等宽字体的 JSON 表示 MySQL 的 JSON 数据类型，而普通字体的 “JSON” 表示一般意义上的 JSON 数据。



存储 JSON 文档所需的空间与 LONGBLOB 或 LONGTEXT 大致相同（见 [13.7 数据类型存储需求](#137-数据类型存储需求)）。

存储在 JSON 列中的文档大小受 max_allowed_packet 系统变量限制（内存中操作时可超过该值）。

使用 JSON_STORAGE_SIZE() 可获取存储 JSON 文档所需的空间（注意：对于 JSON 列，该值是在执行任何部分更新之前的大小）。



MySQL 8.0.13 之前，JSON 列不能有非 NULL 的默认值。



MySQL 提供了一系列 **SQL JSON 函数** 来创建、修改和搜索 JSON 值（见 [14.17 JSON 函数](#1417-json-函数)）。

此外，还提供一组 **空间函数** 用于操作 GeoJSON（见 [14.16.11 空间 GeoJSON 函数](#141611-空间-geojson-函数)）。



JSON 列不能直接建立索引，但可在 **生成列（generated column）** 上建立索引，该列从 JSON 列提取标量值（见 *为 JSON 列创建索引的生成列*）。

MySQL 8.0.17+ 的 InnoDB 还支持 **多值索引（multi-valued index）**，可作用于 JSON 数组。



在 NDB Cluster 8.0 中，最多可有 3 个 JSON 列，且支持 JSON 函数及通过生成列创建索引。



------





## **部分更新 JSON 值**





MySQL 8.0 支持 **部分原地更新** JSON 列，而不是每次更新都重写整个文档。此优化在以下条件下生效：



- 列声明为 JSON

- 使用 JSON_SET()、JSON_REPLACE() 或 JSON_REMOVE() 进行更新

  > 直接赋值（如 UPDATE t SET jcol='{"a":1}'）不支持部分更新

- 多个 JSON 列可同时部分更新，但仅限使用上述 3 个函数的列

- 输入列与目标列必须是同一列（jcol1 = JSON_SET(jcol2,...) 不支持）

- 可嵌套调用上述函数，前提是输入和目标列相同

- 更新只替换现有数组或对象，不新增元素

- 新值大小不能大于旧值（除非旧的部分更新已留出足够空间，可用 JSON_STORAGE_FREE() 查看）





此类部分更新可通过 binlog_row_value_options=PARTIAL_JSON 以紧凑格式记录到二进制日志中。

