## 13.5 JSON 数据类型

**目录**

- [部分更新 JSON 值](#部分更新 JSON 值)
- [创建 JSON 值](#创建 JSON 值)
- [JSON 值的规范化、合并和自动封装](#JSON 值的规范化、合并和自动封装)
- [搜索和修改 JSON 值](#搜索和修改 JSON 值)
- [JSON 路径语法](#JSON 路径语法)
- [JSON 值的比较与排序](#JSON 值的比较与排序)
- [JSON 与非 JSON 值之间的转换](#JSON 与非 JSON 值之间的转换)
- [JSON 值的聚合](#JSON 值的聚合)

MySQL 支持符合 [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259) 定义的原生 `JSON`（`JavaScript Object Notation`）数据类型，可高效访问 JSON 文档中的数据。

相比将 `JSON` 格式字符串存储在字符串列中，JSON 数据类型具有以下优势：

- **自动验证**。存储在 `JSON` 列中的 `JSON` 文档会自动验证，**无效文档会产生错误**。
- **优化存储格式**。`JSON` 文档会被转换成内部二进制格式，便于快速读取元素，无需从文本解析，可直接按 **键** 或 **数组索引** 定位子对象或嵌套值，而无需读取整个文档。

MySQL 还支持 [**RFC 7396**](https://datatracker.ietf.org/doc/html/rfc7396) 定义的 JSON Merge Patch 格式，通过 JSON_MERGE_PATCH() 函数实现。详细示例见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。

> **注意**
>
> 在本节中，等宽字体的 `JSON` 表示 MySQL 的 `JSON` 数据类型，而普通字体的 “JSON” 表示一般意义上的 JSON 数据。

存储 `JSON` 文档所需的空间与 `LONGBLOB` 或 `LONGTEXT` 大致相同（见 [13.7 数据类型存储需求](#137-数据类型存储需求)）。存储在 `JSON` 列中的文档大小受 `max_allowed_packet` 系统变量限制（内存中操作时可超过该值）。使用 `JSON_STORAGE_SIZE()` 可获取存储 JSON 文档所需的空间（注意：对于 JSON 列，该值是在执行任何部分更新之前的大小）。

MySQL 8.0.13 之前，JSON 列不能有非 NULL 的默认值。

MySQL 提供了一系列 **SQL JSON 函数** 来创建、修改和搜索 JSON 值（见 [14.17 JSON 函数](#1417-json-函数)）。

此外，还提供一组 **空间函数** 用于操作 GeoJSON（见 [14.16.11 空间 GeoJSON 函数](#141611-空间-geojson-函数)）。

JSON 列不能直接建立索引，但可在 **生成列（generated column）** 上建立索引，该列从 JSON 列提取标量值（见 *为 JSON 列创建索引的生成列*）。

MySQL 8.0.17+ 的 InnoDB 还支持 **多值索引（multi-valued index）**，可作用于 JSON 数组。在 NDB Cluster 8.0 中，最多可有 3 个 JSON 列，且支持 JSON 函数及通过生成列创建索引。

### 部分更新 JSON 值

在 **MySQL 8.0** 中，优化器可以对 `JSON` 列执行 **部分原地更新**（partial, in-place update），而不是删除旧文档并将整个新文档重新写入列中。这种优化可在满足以下条件时执行：

- **更新的列必须声明为 JSON 类型**。

- **UPDATE 语句必须使用以下三个函数之一** 来更新列`：JSON_SET()`、`JSON_REPLACE()`和`JSON_REMOVE()`，直接赋值（例如`UPDATE mytable SET jcol = '{"a": 10, "b": 25}';`）无法执行部分更新。

  在单条 UPDATE 语句中可以优化多个 JSON 列的更新，但仅限使用上述三个函数更新的列。

- **输入列和目标列必须是同一列**。例如：`UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100);`不支持部分更新。

  可以嵌套调用上述任意函数，顺序和组合不限，只要输入列和目标列相同即可。

- 所有更改都必须是用新值替换现有数组或对象值，**不能向父对象或数组添加新元素**。

- **新值的大小不能超过旧值**。换句话说，被替换的值必须至少和新值一样大。

  例外：如果之前的部分更新留下了足够的空闲空间，则可存储更大的值。可使用 `JSON_STORAGE_FREE()` 查看 `JSON` 列经过部分更新后释放了多少空间。

这种部分更新可以用紧凑格式写入二进制日志（节省空间），可通过设置 `binlog_row_value_options` 系统变量为 `PARTIAL_JSON` 启用。

**表中 JSON 列值的部分更新** 与 **在二进制日志中部分写入 JSON 更新** 并不完全相同。即使是对 JSON 列的**完整更新**，在二进制日志中也可能被记录为**部分更新**。这种情况会发生在前述条件列表中的**最后两个条件**中有一个（或两个）不满足但其他条件均满足的情况下。

更多信息可参考 `binlog_row_value_options` 的说明。

接下来的小节将提供有关 **创建和操作 `JSON` 值** 的基本信息。

### 创建 JSON 值

**JSON 数组** 是由逗号分隔的值组成的列表，并用方括号 [ 和 ] 包裹，例如：

```json
["abc", 10, null, true, false]
```

**JSON 对象** 是由逗号分隔的键值对组成的集合，并用花括号 { 和 } 包裹，例如：

```json
{"k1": "value", "k2": 10}
```

如上述示例所示，JSON 数组和对象可以包含以下类型的标量值：字符串、数字、JSON 字面量 null、和JSON 布尔字面量 true 或 false。**JSON 对象的键必须是字符串**。还允许使用时间类型（日期、时间或日期时间）作为标量值，例如：

```json
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
```

在 JSON 数组的元素和 JSON 对象的键值中允许嵌套，例如：

```json
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```

MySQL 还提供了多个用于生成 JSON 值的函数（见 [14.17.2 创建 JSON 值的函数](#14172-创建-json-值的函数)），也可以使用 `CAST(value AS JSON)` 将其他类型的值转换为 JSON 类型（见 **JSON 与非 JSON 值之间的转换**）。

在 MySQL 中，JSON 值以字符串形式书写。MySQL 会解析出现在需要 JSON 值的上下文中的任何字符串，如果该字符串不是有效 JSON，就会产生错误。这些上下文包括：向声明为 JSON 数据类型的列插入值，将参数传递给需要 JSON 值的函数（在文档中通常表示为 json_doc 或 json_val）。插入 JSON 值示例

- 如果值是合法 JSON，则插入成功；如果不是合法 JSON，则插入失败：

    ```mysql
    mysql> CREATE TABLE t1 (jdoc JSON);
    Query OK, 0 rows affected (0.20 sec)
    
    mysql> INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
    Query OK, 1 row affected (0.01 sec)
    
    mysql> INSERT INTO t1 VALUES('[1, 2,');
    ERROR 3140 (22032) at line 2: Invalid JSON text:
    "Invalid value." at position 6 in value (or column) '[1, 2,'.
    ```

	错误信息中 "`at position N`" 的位置是从 0 开始计数的，大致表示问题出现的位置。

- `JSON_TYPE()` 函数需要 JSON 参数，如果是合法 JSON，则返回其类型，否则报错：

  ```mysql
  mysql> SELECT JSON_TYPE('["a", "b", 1]');
  +----------------------------+
  | JSON_TYPE('["a", "b", 1]') |
  +----------------------------+
  | ARRAY                      |
  +----------------------------+
  
  mysql> SELECT JSON_TYPE('"hello"');
  +----------------------+
  | JSON_TYPE('"hello"') |
  +----------------------+
  | STRING               |
  +----------------------+
  
  mysql> SELECT JSON_TYPE('hello');
  ERROR 3146 (22032): Invalid data type for JSON data in argument 1
  to function json_type; a JSON string or JSON type is required.
  ```

JSON 上下文中的字符串使用 utf8mb4 字符集和 utf8mb4_bin 排序规则。其他字符集会根据需要转换为 utf8mb4。对于 ascii 和 utf8mb3，不需要转换，因为它们是 utf8mb4 的子集。

**JSON_ARRAY()**：接收一个（可能为空的）值列表，返回一个 JSON 数组：

```mysql
mysql> SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
```

**JSON_OBJECT()**：接收一个（可能为空的）键值对列表，返回一个 JSON 对象：

```mysql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
```

**JSON_MERGE_PRESERVE()**：合并两个或更多 JSON 文档：

```mysql
mysql> SELECT JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}');
+-----------------------------------------------------+
| JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}') |
+-----------------------------------------------------+
| ["a", 1, {"key": "value"}]                          |
+-----------------------------------------------------+
1 row in set (0.00 sec)
```

关于合并规则，请参见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。

从 MySQL 8.0.3 开始，还支持 JSON_MERGE_PATCH()，其行为与 JSON_MERGE_PRESERVE() 略有不同。

JSON 值可以赋给用户定义变量：

```mysql
mysql> SET @j = JSON_OBJECT('key', 'value');
mysql> SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
```

但是，用户定义变量不能是 JSON 数据类型，因此即使 @j 的显示结果看起来像 JSON，并且具有相同的字符集和排序规则，它实际上是字符串类型（赋值时由 JSON 转为字符串）。

转换自 JSON 值的字符串具有 utf8mb4 字符集和 utf8mb4_bin 排序规则：

```mysql
mysql> SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
```

由于 utf8mb4_bin 是二进制排序规则，比较 JSON 值时区分大小写：

```mysql
mysql> SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
```

JSON 字面量 null、true、false 必须用小写：

```mysql
mysql> SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql> SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
```

与此不同，SQL 字面量 NULL、TRUE、FALSE 可用任意大小写。

```mysql
mysql> SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
```

有时可能需要或希望在 JSON 文档中插入引号字符（" 或 '）。例如，假设你想插入一些 JSON 对象，这些对象包含表示关于 MySQL 的事实性句子的字符串，并且每个句子都与一个合适的关键字配对。假设我们使用以下 SQL 语句创建了一个表：

```mysql
CREATE TABLE facts (sentence JSON);
```

假设我们有如下 JSON 对象：

```
mascot: The MySQL mascot is a dolphin named "Sakila".
```

使用 JSON_OBJECT() 插入时，可以用反斜杠转义引号：

```sql
INSERT INTO facts VALUES
  (JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));
```

作为 JSON 字面量插入时，需使用双反斜杠：

```mysql
INSERT INTO facts VALUES
  ('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');
```

双反斜杠可以防止 MySQL 执行转义序列解析，而是将字符串原样传递给存储引擎。插入完成后，查询会显示带有转义的值：

```mysql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

使用 `->` 按路径提取时，会保留引号和转义：

```mysql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

使用 `->>` 提取时，会去掉引号和转义：

```mysql
mysql> SELECT col->"$.mascot" FROM qtest;
+---------------------------------------------+
| col->"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
```

> **注意**
>
> 如果启用了 NO_BACKSLASH_ESCAPES SQL 模式，则上述双反斜杠写法不适用：
>
> - JSON 字面量可用单反斜杠
>
> - 使用 JSON_OBJECT() 插入时，可交替使用单引号和双引号，例如：
>
>   ```mysql
>   mysql> INSERT INTO facts VALUES
>        > (JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));
>   ```
>
> 关于该模式对 JSON 值中转义字符的影响，见 JSON_UNQUOTE() 的说明。

### JSON 值的规范化、合并和自动封装

当字符串被解析并且是一个合法的 JSON 文档时，它也会被**规范化（normalized）**。

规范化意味着：从左到右扫描，如果某个键（key）重复出现，则**丢弃前面出现的同名键**，只保留最后出现的键值对。例如：

```mysql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": "def", "key2": "abc"}                       |
+------------------------------------------------------+
```

在将值插入 JSON 列时，也会执行同样的规范化处理：

```mysql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+------------------+
| c1               |
+------------------+
| {"x": "red"}     |
| {"x": [3, 5, 7]} |
+------------------+
```

这种 **“最后出现的重复键获胜”** 的行为是 **RFC 7159** 推荐的，并且大多数 JavaScript 解析器也采用这种方式。

在 8.0.3 之前，重复键处理采用的是 **“第一次出现的重复键获胜”** 规则：

```mysql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
```

插入 JSON 列时也会执行这种“保留第一个重复键”的规范化：

```
CREATE TABLE t1 (c1 JSON);

INSERT INTO t1 VALUES
    ('{"x": 17, "x": "red"}'),
    ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

SELECT c1 FROM t1;
-- {"x": 17}
-- {"x": 17}
```

MySQL 会删除原始 JSON 文档中键、值或元素之间的多余空格。在显示时，每个逗号（,）或冒号（:）后面会保留（或必要时插入）一个空格，以增强可读性。

所有 MySQL 生成 JSON 值的函数（见 [14.17.2 创建 JSON 值的函数](#14172-创建-json-值的函数)）都返回规范化后的值。

为了提高查找效率，MySQL 还会对 JSON 对象的键进行排序。键的排序结果可能会在不同版本间变化，并不保证跨版本一致。

#### JSON 值的合并

MySQL 8.0.3（及更高版本）支持两种合并算法，通过以下函数实现：`JSON_MERGE_PRESERVE()`和`JSON_MERGE_PATCH()`。

它们在处理**重复键**时的行为不同：`JSON_MERGE_PRESERVE()`保留重复键的所有值，`JSON_MERGE_PATCH()`丢弃重复键的所有值，仅保留最后一个。

> **注意**
>
> `JSON_MERGE_PRESERVE()` 与旧版本 MySQL 中的 `JSON_MERGE()` 功能相同（8.0.3 起更名）。`JSON_MERGE()` 仍作为 `JSON_MERGE_PRESERVE()` 的别名存在，但已废弃，未来版本可能移除。

**数组合并**：在合并多个数组的上下文中，这些数组会被合并成一个单一的数组。`JSON_MERGE_PRESERVE()` 的做法是：将后面出现的数组依次连接到第一个数组的末尾。`JSON_MERGE_PATCH()` 的做法是：将每个参数视为一个只包含单个元素的数组（索引为 0），然后应用 **“最后一个重复键获胜”** 的规则，只保留最后一个参数。

```mysql
mysql> SELECT
    ->   JSON_MERGE_PRESERVE('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Preserve,
    ->   JSON_MERGE_PATCH('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Patch\G
*************************** 1. row ***************************
Preserve: [1, 2, "a", "b", "c", true, false]
   Patch: [true, false]
```

多个对象在合并时会生成一个单一对象。`JSON_MERGE_PRESERVE()` 在处理多个具有相同键的对象时，会将该键的所有唯一值组合成一个数组；然后，这个数组会作为该键在结果中的值。`JSON_MERGE_PATCH()` 会从左到右扫描，对于重复的键会丢弃前面的值，因此结果中该键只保留最后一个值。下面的查询展示了键 a 重复时两种方法在结果上的差异：

```mysql
mysql> SELECT
    ->   JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Preserve,
    ->   JSON_MERGE_PATCH('{"a": 3, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Patch\G
*************************** 1. row ***************************
Preserve: {"a": [1, 4], "b": 2, "c": [3, 5], "d": 3}
   Patch: {"a": 4, "b": 2, "c": 5, "d": 3}
```

在需要数组值的上下文中，如果提供的值不是数组，则会自动封装（autowrap）：该值会被方括号 [ 和 ] 包裹，以将其转换为数组。在下面的语句中，每个参数都会被自动封装为数组（[1]、[2]）。然后，这些数组会被合并成一个结果数组；与前两个示例相同，`JSON_MERGE_PRESERVE()` 会合并相同键的值，而 `JSON_MERGE_PATCH()` 会丢弃除最后一个之外的所有重复键的值，如下所示：

```mysql
mysql> SELECT
	  ->   JSON_MERGE_PRESERVE('1', '2') AS Preserve,
	  ->   JSON_MERGE_PATCH('1', '2') AS Patch\G
*************************** 1. row ***************************
Preserve: [1, 2]
   Patch: 2
```

数组值与对象值的合并过程是：先将对象自动封装为数组，然后将数组进行合并；合并方式取决于所选择的合并函数（`JSON_MERGE_PRESERVE()` 或 `JSON_MERGE_PATCH()`）——要么组合所有值，要么采用“最后一个重复键获胜”的规则，正如下例所示：

```mysql
mysql> SELECT
	  ->   JSON_MERGE_PRESERVE('[10, 20]', '{"a": "x", "b": "y"}') AS Preserve,
	  ->   JSON_MERGE_PATCH('[10, 20]', '{"a": "x", "b": "y"}') AS Patch\G
*************************** 1. row ***************************
Preserve: [10, 20, {"a": "x", "b": "y"}]
   Patch: {"a": "x", "b": "y"}
```

### 搜索和修改 JSON 值

JSON 路径表达式用于在 JSON 文档中选择某个值。

路径表达式常与提取或修改 JSON 文档部分内容的函数配合使用，用来指定在文档的哪个位置进行操作。例如，下面的查询从 JSON 文档中提取 name 键对应的值：

```mysql
mysql> SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                        |
+---------------------------------------------------------+
```

路径语法以 $ 开头，表示当前所处理的 JSON 文档，后面可以跟选择器，用于逐步指定更精确的部分：

- **. + 键名**：访问对象中给定键的成员。如果键名不符合路径表达式的命名规则（如包含空格），必须用双引号括起来。
- **[N]**：访问数组中第 N 个位置的值（从 0 开始）。如果路径选中的是非数组值，那么 *path[0]* 的结果等同于 *path*。

```mysql
mysql> SELECT JSON_SET('"x"', '$[0]', 'a');
+------------------------------+
| JSON_SET('"x"', '$[0]', 'a') |
+------------------------------+
| "a"                          |
+------------------------------+
1 row in set (0.00 sec)
```

- **[M to N]**：访问数组中从位置 M 到位置 N 的子集（包含两端元素）。

  **last**：表示数组最后一个元素的索引，支持相对定位（如 last-1）。

- 路径可以包含\*和\*\*通配符：

  - *.\**：获取 JSON 对象中所有成员的值。
  - *[\*]*：获取 JSON 数组中所有元素的值。
  - *prefix**suffix*：获取所有以 prefix 开头并以 suffix 结尾的路径。


- 如果路径在文档中不存在，则结果为 NULL。


设 $ 为以下 JSON 数组：

```json
[3, {"a": [5, 6], "b": 10}, [99, 100]]
```

那么：

- $[0] → 3
- $[1] → {"a": [5, 6], "b": 10}
- $[2] → [99, 100]
- $[3] → NULL（不存在）

可继续在非标量值基础上使用更具体的路径：

- $[1].a → [5, 6]
- $[1].a[1] → 6
- $[1].b → 10
- $[2]\[0\] → 99

正如前面提到的，如果路径中的键名在路径表达式中不合法，那么命名该键的路径组件必须加引号。假设 **$** 指代如下的值：

```json
{"a fish": "shark", "a bird": "sparrow"}
```

键名包含空格时需加引号：

- $."a fish" → shark
- $."a bird" → sparrow

使用通配符的路径会被解析为一个数组，该数组可以包含多个值：

```mysql
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
```

在下面的例子中，路径 `$**.b` 会解析为多个路径（`$.a.b` 和 `$.c.b`），并生成一个包含这些匹配路径值的数组：

```mysql
mysql> SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
```

**来自 JSON 数组的范围（Ranges from JSON arrays）**。你可以在 JSON 数组中使用 **to** 关键字来指定数组的子集范围。例如，$[1 to 3] 表示数组的**第二、第三和第四个元素**，如下所示：

```mysql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]');
+----------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]') |
+----------------------------------------------+
| [2, 3, 4]                                    |
+----------------------------------------------+
1 row in set (0.00 sec)
```

语法为 **M to N**，其中 M 和 N 分别是 JSON 数组中一段元素范围的第一个和最后一个索引。N 必须大于 M，M 必须大于或等于 0。数组元素的索引从 **0** 开始。

在支持通配符的上下文中，可以使用范围。

**最右侧数组元素（Rightmost array element）**。关键字 `last` 可以作为数组最后一个元素索引的同义词。表达式 `last - N` 可用于相对定位，也可用于范围定义中，例如：

```mysql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]');
+--------------------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]') |
+--------------------------------------------------------+
| [2, 3, 4]                                              |
+--------------------------------------------------------+
1 row in set (0.01 sec)
```

如果路径在一个非数组值上进行求值，结果与将该值封装在一个单元素数组中的效果相同：

```mysql
mysql> SELECT JSON_REPLACE('"Sakila"', '$[last]', 10);
+-----------------------------------------+
| JSON_REPLACE('"Sakila"', '$[last]', 10) |
+-----------------------------------------+
| 10                                      |
+-----------------------------------------+
1 row in set (0.00 sec)
```

可以使用 `column->path`（`JSON` 列标识符 + JSON 路径表达式）作为 `JSON_EXTRACT(column, path)` 的同义写法。更多信息参见 14.17.3 Functions That Search JSON Values，以及 Indexing a Generated Column to Provide a JSON Column Index。

有些函数会获取一个已存在的 JSON 文档，对其进行某种修改，并返回修改后的文档。路径表达式用于指定在文档中的修改位置。它们都接收一个 JSON 文档，以及一个或多个 **路径-值（path-value）** 对，用来描述修改位置和使用的值。它们的区别在于处理文档中**已存在**和**不存在**的值时的行为不同。

假设有以下文档：

```json
SET @j = '["a", {"b": [true, false]}, [10, 20]]';
```

`JSON_SET()`替换已存在路径的值，并为不存在的路径添加新值：

```mysql
mysql> SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
```

在这个例子中，路径 `$[1].b[0]` 选择了已存在的值 true，它被替换成 1。路径 `$[2][2]` 不存在，因此值 2 被添加到 `$[2]` 所选择的数组末尾。

`JSON_INSERT()`仅添加新值，不替换已存在的值：

```mysql
mysql> SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
```

`JSON_REPLACE()`仅替换已存在的值，忽略新值：

```mysql
mysql> SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
```

**路径-值对** 按从左到右的顺序依次计算。每次计算产生的文档会作为下一个路径-值对的基础进行处理。

`JSON_REMOVE()`接收一个 JSON 文档，以及一个或多个路径，移除文档中与这些路径匹配的值。返回值是原始文档**减去**这些已匹配路径的值：

```mysql
mysql> SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
```

路径的作用如下：

1. `$[2]` 匹配 `[10, 20]` 并将其移除。
2. 第一次 `$[1].b[1]` 匹配到 b 元素中的 false 并将其移除。
3. 第二次 `$[1].b[1]` 不匹配任何内容（因为元素已被移除），因此无效果。

### JSON 路径语法

MySQL 支持的许多 JSON 函数（详见本手册 **14.17 “JSON Functions”** 节）需要使用路径表达式来标识 JSON 文档中的特定元素。路径由路径的作用域（scope）后跟一个或多个路径段（path legs）组成。对于在 MySQL JSON 函数中使用的路径，其作用域始终是正在被搜索或操作的文档，并由一个前导 **$** 字符表示。路径段之间用句点（.）分隔。数组中的单元格用 **[N]** 表示，其中 **N** 是非负整数。键名必须是双引号括起来的字符串，或有效的 ECMAScript 标识符（参见 *ECMAScript Language Specification* 中的 *Identifier Names and Identifiers*）。路径表达式与 JSON 文本类似，应使用 **ascii**、**utf8mb3** 或 **utf8mb4** 字符集进行编码。其他字符编码会被隐式转换为 **utf8mb4**。完整语法如下所示：

```
pathExpression:
    scope[(pathLeg)*]

pathLeg:
    member | arrayLocation | doubleAsterisk

member:
    period ( keyName | asterisk )

arrayLocation:
    leftBracket ( nonNegativeInteger | asterisk ) rightBracket

keyName:
    ESIdentifier | doubleQuotedString

doubleAsterisk:
    '**'

period:
    '.'

asterisk:
    '*'

leftBracket:
    '['

rightBracket:
    ']'
```

如前所述，在 MySQL 中，路径的作用域始终是正在操作的文档，用 **$** 表示。你可以在 JSON 路径表达式中使用 **$** 作为文档的同义符号。

> **注意**
>
> 一些实现支持在 JSON 路径作用域中使用列引用，但 MySQL 8.0 **不支持**此功能。

通配符 * 和 \*\* 的用法如下：

- `.*` 表示对象中所有成员的值。

- `[*]` 表示数组中所有单元格的值。

- `[prefix]**suffix` 表示所有以 prefix 开头、以 suffix 结尾的路径。`prefix` 是可选的，`suffix` 是必需的，路径不能以 `**` 结尾。

  此外，路径中不能包含 *** 这样的序列。

关于路径语法的示例，可参考接受路径作为参数的 JSON 函数，如：`JSON_CONTAINS_PATH()`、`JSON_SET()`和`JSON_REPLACE()`。包含 `*` 和 `**` 通配符的路径示例，可参考 `JSON_SEARCH()` 的说明。

MySQL 8.0 还支持使用 `to` 关键字的范围表示法（如 `$[2 to 10]`），以及关键字 `last` 作为数组最后一个元素的同义词。详情和示例可参考 **Searching and Modifying JSON Values**。

### JSON 值的比较与排序

JSON 值可以使用以下运算符进行比较：`=`, `<`, `<=`, `>`, `>=`, `<>`, `!=`, `<=>`。

以下比较运算符和函数**尚不支持** JSON 值：

- `BETWEEN`
- `IN()`
- `GREATEST()`
- `LEAST()`

对于前面列出的比较运算符和函数，一种解决方法是将 JSON 值转换为 MySQL 原生的数值类型或字符串类型，使其具有一致的非 `JSON` 标量类型。

`JSON` 值的比较分为两个层级。第一级比较基于被比较值的 `JSON` 类型。如果类型不同，比较结果完全由类型的优先级决定。如果两个值的 `JSON` 类型相同，则会进入第二级比较，使用该类型特定的规则进行比较。

下面的列表显示了 `JSON` 类型的优先级，从最高到最低。（类型名称是 `JSON_TYPE()` 函数返回的值。）同一行显示的类型具有相同的优先级。任何具有在列表中靠前的 `JSON` 类型的值都大于具有在列表中靠后的 `JSON` 类型的值。

```
BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
```

对于具有相同优先级的 JSON 值，其比较规则依赖于具体类型：

- **BLOB**

  比较两个值的前 N 个字节，其中 N 是较短值的字节数。

  如果前 N 个字节相同，则较短的值排在较长的值之前。

- **BIT**

  与 BLOB 类型的规则相同。

- **OPAQUE**

  与 BLOB 类型的规则相同。OPAQUE 类型是指不属于其他已分类类型的值。

- **DATETIME**

  表示较早时间点的值排在表示较晚时间点的值之前。

  如果两个值分别来自 MySQL 的 DATETIME 和 TIMESTAMP 类型，并且它们表示相同的时间点，则它们相等。

- **TIME**

  较小的时间值排在较大的时间值之前。

- **DATE**

  较早的日期排在较晚的日期之前。

- **ARRAY**

  两个 JSON 数组在长度相同且对应位置的值相等时才相等。

  如果数组不相等，则比较在第一个存在差异的位置上的元素，较小的值所在的数组排在前面。

  如果较短数组的所有值都等于较长数组的对应值，则较短的数组排在前面。

  示例：

    ```json
    [] < ["a"] < ["ab"] < ["ab", "cd", "ef"] < ["ab", "ef"]
    ```

- **BOOLEAN**

  JSON 中的 false 字面量小于 true 字面量。

- **OBJECT**

  两个 JSON 对象在键集合相同且每个键在两个对象中的值都相同时才相等。

  示例：

  ```json
  {"a": 1, "b": 2} = {"b": 2, "a": 1}
  ```

  两个不相等的对象，其顺序未定义但具有确定性。


- **STRING**

  字符串按照其 utf8mb4 表示形式的前 N 个字节进行字典序排序，其中 N 是较短字符串的长度。

  如果前 N 个字节相同，则较短的字符串排在较长的字符串之前。

  示例：

    ```json
    "a" < "ab" < "b" < "bc"
    ```

  这种排序等同于使用 **utf8mb4_bin** 排序规则的 SQL 字符串的排序方式。由于 **utf8mb4_bin** 是二进制排序规则，JSON 值的比较区分大小写：

    ```json
    "A" < "a"
    ```

- **INTEGER, DOUBLE**

  JSON 值可以包含精确值（exact-value numbers）和近似值（approximate-value numbers）。

  关于这些数值类型的常规讨论，请参见 **11.1.2 “Numeric Literals”**。原生 MySQL 数值类型的比较规则参见 **14.3 “Type Conversion in Expression Evaluation”**，但 JSON 数值比较规则稍有不同：

  - 当比较一个 INT 类型列和一个 DOUBLE 类型列时，可以确定所有比较都涉及整数和双精度浮点数，因此整数会在所有行中被转换为双精度浮点数（即精确值被转换为近似值）。

  - 但是，当比较两个 JSON 列时，无法预先确定数值是整数还是双精度浮点数。为了在所有行中提供一致的行为，MySQL 会将近似值转换为精确值。这种转换保证了排序一致，并且不会丢失精确值的精度。例如，给定以下标量：9223372036854775805, 9223372036854775806, 9223372036854775807, 9.223372036854776e18，排序结果如下：

      ```json
      9223372036854775805 < 9223372036854775806 < 9223372036854775807
      < 9.223372036854776e18 = 9223372036854776000 < 9223372036854776001
      ```

如果 JSON 比较使用非 JSON 数值比较规则，则可能出现不一致的排序。

MySQL 常规数值比较规则的排序结果为：

- 整数比较：

  ```json
  9223372036854775805 < 9223372036854775806 < 9223372036854775807
  ```

  （对 9.223372036854776e18 未定义）

- 双精度比较：

  ```json
  9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
  ```


任意 JSON 值与 `SQL NULL` 的比较结果为 `UNKNOWN`。

当比较 JSON 值与非 JSON 值时，非 JSON 值会根据下表的规则转换为 JSON，然后再按照上述规则进行比较。

### JSON 与非 JSON 值之间的转换

下表总结了 MySQL 在 JSON 值与其他类型值之间进行类型转换时遵循的规则：

**表 13.3 JSON 转换规则**

| **其他类型**                              | **CAST(其他类型 AS JSON)**                                   | **CAST(JSON AS 其他类型)**                                   |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| JSON                                      | 无变化                                                       | 无变化                                                       |
| UTF-8 字符类型（utf8mb4、utf8mb3、ascii） | 将字符串解析为 JSON 值                                       | 将 JSON 值序列化为 utf8mb4 字符串                            |
| 其他字符类型                              | 其他字符编码会被隐式转换为 utf8mb4，并按照 UTF-8 字符类型的规则处理 | 将 JSON 值序列化为 utf8mb4 字符串，然后再转换为其他字符编码。结果可能无意义 |
| NULL                                      | 生成一个类型为 JSON 的 NULL 值                               | 不适用                                                       |
| 几何类型                                  | 调用 ST_AsGeoJSON() 将几何值转换为 JSON 文档                 | 非法操作。解决方法：将 CAST(json_val AS CHAR) 的结果传给 ST_GeomFromGeoJSON() |
| 其他所有类型                              | 生成一个由单一标量值组成的 JSON 文档                         | 如果 JSON 文档由单一目标类型的标量值组成，并且该标量值能转换为目标类型，则转换成功；否则返回 NULL 并产生警告 |

JSON 值的 ORDER BY 和 GROUP BY 遵循以下原则：

- 对标量 JSON 值的排序规则与前文讨论的一致。
- 升序排序时，SQL NULL 排在所有 JSON 值之前（包括 JSON 的 null 字面量）；降序排序时，SQL NULL 排在所有 JSON 值之后（包括 JSON 的 null 字面量）。
- JSON 值的排序键受系统变量 max_sort_length 的限制，因此仅在前 max_sort_length 个字节相同的键会被视为相等。
- 当前不支持对非标量值进行排序，尝试排序会产生警告。

在排序时，将 JSON 标量转换为 MySQL 原生类型可能更高效。例如，如果列 jdoc 中的 JSON 对象包含一个 id 键且其值为非负数，可以使用以下表达式按 id 值排序：

```mysql
ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
```

如果有一个**生成列（generated column）**使用了与 ORDER BY 相同的表达式，MySQL 优化器会识别并考虑在查询执行计划中使用该索引。参见 **10.3.11 “优化器对生成列索引的使用”**。

### JSON 值的聚合

对 JSON 值进行聚合时，SQL NULL 值会被忽略，与其他数据类型一致。非 NULL 值会被转换为数值类型并进行聚合（MIN()、MAX() 和 GROUP_CONCAT() 除外）。对数值型标量的 JSON 值进行转换时通常会产生有意义的结果，但根据具体值可能会发生截断或精度丢失。对其他类型的 JSON 值进行数值转换时，结果可能没有实际意义。
