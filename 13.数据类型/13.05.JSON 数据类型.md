## 13.5 JSON 数据类型

**目录**

- [部分更新 JSON 值](#部分更新 JSON 值)
- [创建 JSON 值](#创建 JSON 值)
- [JSON 值的规范化、合并和自动封装](#JSON 值的规范化、合并和自动封装)
- [搜索与修改 JSON 值](#搜索与修改 JSON 值)
- [JSON 路径语法](#JSON 路径语法)
- [JSON 值的比较与排序](#JSON 值的比较与排序)
- [JSON 与非 JSON 值之间的转换](#JSON 与非 JSON 值之间的转换)
- [JSON 值的聚合](#JSON 值的聚合)

MySQL 支持符合 [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259) 定义的原生 `JSON`（`JavaScript Object Notation`）数据类型，可高效访问 JSON 文档中的数据。

相比将 `JSON` 格式字符串存储在字符串列中，JSON 数据类型具有以下优势：

- **自动验证**。存储在 `JSON` 列中的 `JSON` 文档会自动验证，**无效文档会产生错误**。
- **优化存储格式**。`JSON` 文档会被转换成内部二进制格式，便于快速读取元素，无需从文本解析，可直接按 **键** 或 **数组索引** 定位子对象或嵌套值，而无需读取整个文档。

MySQL 还支持 [**RFC 7396**](https://datatracker.ietf.org/doc/html/rfc7396) 定义的 JSON Merge Patch 格式，通过 JSON_MERGE_PATCH() 函数实现。详细示例见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。

> **注意**
>
> 在本节中，等宽字体的 `JSON` 表示 MySQL 的 `JSON` 数据类型，而普通字体的 “JSON” 表示一般意义上的 JSON 数据。

存储 `JSON` 文档所需的空间与 `LONGBLOB` 或 `LONGTEXT` 大致相同（见 [13.7 数据类型存储需求](#137-数据类型存储需求)）。存储在 `JSON` 列中的文档大小受 `max_allowed_packet` 系统变量限制（内存中操作时可超过该值）。使用 `JSON_STORAGE_SIZE()` 可获取存储 JSON 文档所需的空间（注意：对于 JSON 列，该值是在执行任何部分更新之前的大小）。

MySQL 8.0.13 之前，JSON 列不能有非 NULL 的默认值。

MySQL 提供了一系列 **SQL JSON 函数** 来创建、修改和搜索 JSON 值（见 [14.17 JSON 函数](#1417-json-函数)）。

此外，还提供一组 **空间函数** 用于操作 GeoJSON（见 [14.16.11 空间 GeoJSON 函数](#141611-空间-geojson-函数)）。

JSON 列不能直接建立索引，但可在 **生成列（generated column）** 上建立索引，该列从 JSON 列提取标量值（见 *为 JSON 列创建索引的生成列*）。

MySQL 8.0.17+ 的 InnoDB 还支持 **多值索引（multi-valued index）**，可作用于 JSON 数组。在 NDB Cluster 8.0 中，最多可有 3 个 JSON 列，且支持 JSON 函数及通过生成列创建索引。

### 部分更新 JSON 值

在 **MySQL 8.0** 中，优化器可以对 `JSON` 列执行 **部分原地更新**（partial, in-place update），而不是删除旧文档并将整个新文档重新写入列中。这种优化可在满足以下条件时执行：

- **更新的列必须声明为 JSON 类型**。

- **UPDATE 语句必须使用以下三个函数之一** 来更新列`：JSON_SET()`、`JSON_REPLACE()`和`JSON_REMOVE()`，直接赋值（例如`UPDATE mytable SET jcol = '{"a": 10, "b": 25}';`）无法执行部分更新。

  在单条 UPDATE 语句中可以优化多个 JSON 列的更新，但仅限使用上述三个函数更新的列。

- **输入列和目标列必须是同一列**。例如：`UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100);`不支持部分更新。

  可以嵌套调用上述任意函数，顺序和组合不限，只要输入列和目标列相同即可。

- 所有更改都必须是用新值替换现有数组或对象值，**不能向父对象或数组添加新元素**。

- **新值的大小不能超过旧值**。换句话说，被替换的值必须至少和新值一样大。

  例外：如果之前的部分更新留下了足够的空闲空间，则可存储更大的值。可使用 `JSON_STORAGE_FREE()` 查看 `JSON` 列经过部分更新后释放了多少空间。

这种部分更新可以用紧凑格式写入二进制日志（节省空间），可通过设置 `binlog_row_value_options` 系统变量为 `PARTIAL_JSON` 启用。

**表中 JSON 列值的部分更新** 与 **在二进制日志中部分写入 JSON 更新** 并不完全相同。即使是对 JSON 列的**完整更新**，在二进制日志中也可能被记录为**部分更新**。这种情况会发生在前述条件列表中的**最后两个条件**中有一个（或两个）不满足但其他条件均满足的情况下。

更多信息可参考 `binlog_row_value_options` 的说明。

接下来的小节将提供有关 **创建和操作 `JSON` 值** 的基本信息。





