## 13.5 JSON 数据类型

**目录**

- [部分更新 JSON 值](#部分更新 JSON 值)
- [创建 JSON 值](#创建 JSON 值)
- [JSON 值的规范化、合并和自动封装](#JSON 值的规范化、合并和自动封装)
- [搜索与修改 JSON 值](#搜索与修改 JSON 值)
- [JSON 路径语法](#JSON 路径语法)
- [JSON 值的比较与排序](#JSON 值的比较与排序)
- [JSON 与非 JSON 值之间的转换](#JSON 与非 JSON 值之间的转换)
- [JSON 值的聚合](#JSON 值的聚合)

MySQL 支持符合 [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259) 定义的原生 `JSON`（`JavaScript Object Notation`）数据类型，可高效访问 JSON 文档中的数据。

相比将 `JSON` 格式字符串存储在字符串列中，JSON 数据类型具有以下优势：

- **自动验证**。存储在 `JSON` 列中的 `JSON` 文档会自动验证，**无效文档会产生错误**。
- **优化存储格式**。`JSON` 文档会被转换成内部二进制格式，便于快速读取元素，无需从文本解析，可直接按 **键** 或 **数组索引** 定位子对象或嵌套值，而无需读取整个文档。

MySQL 还支持 [**RFC 7396**](https://datatracker.ietf.org/doc/html/rfc7396) 定义的 JSON Merge Patch 格式，通过 JSON_MERGE_PATCH() 函数实现。详细示例见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。

> **注意**
>
> 在本节中，等宽字体的 `JSON` 表示 MySQL 的 `JSON` 数据类型，而普通字体的 “JSON” 表示一般意义上的 JSON 数据。

存储 `JSON` 文档所需的空间与 `LONGBLOB` 或 `LONGTEXT` 大致相同（见 [13.7 数据类型存储需求](#137-数据类型存储需求)）。存储在 `JSON` 列中的文档大小受 `max_allowed_packet` 系统变量限制（内存中操作时可超过该值）。使用 `JSON_STORAGE_SIZE()` 可获取存储 JSON 文档所需的空间（注意：对于 JSON 列，该值是在执行任何部分更新之前的大小）。

MySQL 8.0.13 之前，JSON 列不能有非 NULL 的默认值。

MySQL 提供了一系列 **SQL JSON 函数** 来创建、修改和搜索 JSON 值（见 [14.17 JSON 函数](#1417-json-函数)）。

此外，还提供一组 **空间函数** 用于操作 GeoJSON（见 [14.16.11 空间 GeoJSON 函数](#141611-空间-geojson-函数)）。

JSON 列不能直接建立索引，但可在 **生成列（generated column）** 上建立索引，该列从 JSON 列提取标量值（见 *为 JSON 列创建索引的生成列*）。

MySQL 8.0.17+ 的 InnoDB 还支持 **多值索引（multi-valued index）**，可作用于 JSON 数组。在 NDB Cluster 8.0 中，最多可有 3 个 JSON 列，且支持 JSON 函数及通过生成列创建索引。

### 部分更新 JSON 值

在 **MySQL 8.0** 中，优化器可以对 `JSON` 列执行 **部分原地更新**（partial, in-place update），而不是删除旧文档并将整个新文档重新写入列中。这种优化可在满足以下条件时执行：

- **更新的列必须声明为 JSON 类型**。

- **UPDATE 语句必须使用以下三个函数之一** 来更新列`：JSON_SET()`、`JSON_REPLACE()`和`JSON_REMOVE()`，直接赋值（例如`UPDATE mytable SET jcol = '{"a": 10, "b": 25}';`）无法执行部分更新。

  在单条 UPDATE 语句中可以优化多个 JSON 列的更新，但仅限使用上述三个函数更新的列。

- **输入列和目标列必须是同一列**。例如：`UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100);`不支持部分更新。

  可以嵌套调用上述任意函数，顺序和组合不限，只要输入列和目标列相同即可。

- 所有更改都必须是用新值替换现有数组或对象值，**不能向父对象或数组添加新元素**。

- **新值的大小不能超过旧值**。换句话说，被替换的值必须至少和新值一样大。

  例外：如果之前的部分更新留下了足够的空闲空间，则可存储更大的值。可使用 `JSON_STORAGE_FREE()` 查看 `JSON` 列经过部分更新后释放了多少空间。

这种部分更新可以用紧凑格式写入二进制日志（节省空间），可通过设置 `binlog_row_value_options` 系统变量为 `PARTIAL_JSON` 启用。

**表中 JSON 列值的部分更新** 与 **在二进制日志中部分写入 JSON 更新** 并不完全相同。即使是对 JSON 列的**完整更新**，在二进制日志中也可能被记录为**部分更新**。这种情况会发生在前述条件列表中的**最后两个条件**中有一个（或两个）不满足但其他条件均满足的情况下。

更多信息可参考 `binlog_row_value_options` 的说明。

接下来的小节将提供有关 **创建和操作 `JSON` 值** 的基本信息。

### 创建 JSON 值

**JSON 数组** 是由逗号分隔的值组成的列表，并用方括号 [ 和 ] 包裹，例如：

```json
["abc", 10, null, true, false]
```

**JSON 对象** 是由逗号分隔的键值对组成的集合，并用花括号 { 和 } 包裹，例如：

```json
{"k1": "value", "k2": 10}
```

如上述示例所示，JSON 数组和对象可以包含以下类型的标量值：字符串、数字、JSON 字面量 null、和JSON 布尔字面量 true 或 false。**JSON 对象的键必须是字符串**。还允许使用时间类型（日期、时间或日期时间）作为标量值，例如：

```json
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
```

在 JSON 数组的元素和 JSON 对象的键值中允许嵌套，例如：

```json
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```

MySQL 还提供了多个用于生成 JSON 值的函数（见 [14.17.2 创建 JSON 值的函数](#14172-创建-json-值的函数)），也可以使用 `CAST(value AS JSON)` 将其他类型的值转换为 JSON 类型（见 **JSON 与非 JSON 值之间的转换**）。

在 MySQL 中，JSON 值以字符串形式书写。MySQL 会解析出现在需要 JSON 值的上下文中的任何字符串，如果该字符串不是有效 JSON，就会产生错误。这些上下文包括：向声明为 JSON 数据类型的列插入值，将参数传递给需要 JSON 值的函数（在文档中通常表示为 json_doc 或 json_val）。插入 JSON 值示例

- 如果值是合法 JSON，则插入成功；如果不是合法 JSON，则插入失败：

    ```mysql
    mysql> CREATE TABLE t1 (jdoc JSON);
    Query OK, 0 rows affected (0.20 sec)
    
    mysql> INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
    Query OK, 1 row affected (0.01 sec)
    
    mysql> INSERT INTO t1 VALUES('[1, 2,');
    ERROR 3140 (22032) at line 2: Invalid JSON text:
    "Invalid value." at position 6 in value (or column) '[1, 2,'.
    ```

	错误信息中 "`at position N`" 的位置是从 0 开始计数的，大致表示问题出现的位置。

- `JSON_TYPE()` 函数需要 JSON 参数，如果是合法 JSON，则返回其类型，否则报错：

  ```mysql
  mysql> SELECT JSON_TYPE('["a", "b", 1]');
  +----------------------------+
  | JSON_TYPE('["a", "b", 1]') |
  +----------------------------+
  | ARRAY                      |
  +----------------------------+
  
  mysql> SELECT JSON_TYPE('"hello"');
  +----------------------+
  | JSON_TYPE('"hello"') |
  +----------------------+
  | STRING               |
  +----------------------+
  
  mysql> SELECT JSON_TYPE('hello');
  ERROR 3146 (22032): Invalid data type for JSON data in argument 1
  to function json_type; a JSON string or JSON type is required.
  ```

JSON 上下文中的字符串使用 utf8mb4 字符集和 utf8mb4_bin 排序规则。其他字符集会根据需要转换为 utf8mb4。对于 ascii 和 utf8mb3，不需要转换，因为它们是 utf8mb4 的子集。

**JSON_ARRAY()**：接收一个（可能为空的）值列表，返回一个 JSON 数组：

```mysql
mysql> SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
```

**JSON_OBJECT()**：接收一个（可能为空的）键值对列表，返回一个 JSON 对象：

```mysql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
```

**JSON_MERGE_PRESERVE()**：合并两个或更多 JSON 文档：

```mysql
mysql> SELECT JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}');
+-----------------------------------------------------+
| JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}') |
+-----------------------------------------------------+
| ["a", 1, {"key": "value"}]                          |
+-----------------------------------------------------+
1 row in set (0.00 sec)
```

关于合并规则，请参见 [**JSON 值的规范化、合并和自动封装**](#json-值的规范化合并和自动封装)。

从 MySQL 8.0.3 开始，还支持 JSON_MERGE_PATCH()，其行为与 JSON_MERGE_PRESERVE() 略有不同。

JSON 值可以赋给用户定义变量：

```mysql
mysql> SET @j = JSON_OBJECT('key', 'value');
mysql> SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
```

但是，用户定义变量不能是 JSON 数据类型，因此即使 @j 的显示结果看起来像 JSON，并且具有相同的字符集和排序规则，它实际上是字符串类型（赋值时由 JSON 转为字符串）。

转换自 JSON 值的字符串具有 utf8mb4 字符集和 utf8mb4_bin 排序规则：

```mysql
mysql> SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
```

由于 utf8mb4_bin 是二进制排序规则，比较 JSON 值时区分大小写：

```mysql
mysql> SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
```

JSON 字面量 null、true、false 必须用小写：

```mysql
mysql> SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql> SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
```

与此不同，SQL 字面量 NULL、TRUE、FALSE 可用任意大小写。

```mysql
mysql> SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
```

有时可能需要或希望在 JSON 文档中插入引号字符（" 或 '）。例如，假设你想插入一些 JSON 对象，这些对象包含表示关于 MySQL 的事实性句子的字符串，并且每个句子都与一个合适的关键字配对。假设我们使用以下 SQL 语句创建了一个表：

```mysql
CREATE TABLE facts (sentence JSON);
```

假设我们有如下 JSON 对象：

```
mascot: The MySQL mascot is a dolphin named "Sakila".
```

使用 JSON_OBJECT() 插入时，可以用反斜杠转义引号：

```sql
INSERT INTO facts VALUES
  (JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));
```

作为 JSON 字面量插入时，需使用双反斜杠：

```mysql
INSERT INTO facts VALUES
  ('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');
```

双反斜杠可以防止 MySQL 执行转义序列解析，而是将字符串原样传递给存储引擎。插入完成后，查询会显示带有转义的值：

```mysql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

使用 `->` 按路径提取时，会保留引号和转义：

```mysql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

使用 `->>` 提取时，会去掉引号和转义：

```mysql
mysql> SELECT col->"$.mascot" FROM qtest;
+---------------------------------------------+
| col->"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
```

> **注意**
>
> 如果启用了 NO_BACKSLASH_ESCAPES SQL 模式，则上述双反斜杠写法不适用：
>
> - JSON 字面量可用单反斜杠
>
> - 使用 JSON_OBJECT() 插入时，可交替使用单引号和双引号，例如：
>
>   ```mysql
>   mysql> INSERT INTO facts VALUES
>        > (JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));
>   ```
>
> 关于该模式对 JSON 值中转义字符的影响，见 JSON_UNQUOTE() 的说明。

### JSON 值的规范化、合并和自动封装

当字符串被解析并且是一个合法的 JSON 文档时，它也会被**规范化（normalized）**。

规范化意味着：从左到右扫描，如果某个键（key）重复出现，则**丢弃前面出现的同名键**，只保留最后出现的键值对。例如：

```mysql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": "def", "key2": "abc"}                       |
+------------------------------------------------------+
```

在将值插入 JSON 列时，也会执行同样的规范化处理：

```mysql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+------------------+
| c1               |
+------------------+
| {"x": "red"}     |
| {"x": [3, 5, 7]} |
+------------------+
```

这种 **“最后出现的重复键获胜”** 的行为是 **RFC 7159** 推荐的，并且大多数 JavaScript 解析器也采用这种方式。

在 8.0.3 之前，重复键处理采用的是 **“第一次出现的重复键获胜”** 规则：

```mysql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
```

插入 JSON 列时也会执行这种“保留第一个重复键”的规范化：

```
CREATE TABLE t1 (c1 JSON);

INSERT INTO t1 VALUES
    ('{"x": 17, "x": "red"}'),
    ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

SELECT c1 FROM t1;
-- {"x": 17}
-- {"x": 17}
```

MySQL 会删除原始 JSON 文档中键、值或元素之间的多余空格。在显示时，每个逗号（,）或冒号（:）后面会保留（或必要时插入）一个空格，以增强可读性。

所有 MySQL 生成 JSON 值的函数（见 [14.17.2 创建 JSON 值的函数](#14172-创建-json-值的函数)）都返回规范化后的值。

为了提高查找效率，MySQL 还会对 JSON 对象的键进行排序。键的排序结果可能会在不同版本间变化，并不保证跨版本一致。

下面是 **Merging JSON Values（JSON 值的合并）** 这一段的中文翻译，保持了之前的格式与关键字标记：



------





## **JSON 值的合并（Merging JSON Values）**





MySQL 8.0.3（及更高版本）支持两种合并算法，通过以下函数实现：



- JSON_MERGE_PRESERVE()
- JSON_MERGE_PATCH()





它们在处理**重复键**时的行为不同：



- **JSON_MERGE_PRESERVE()**：保留重复键的所有值
- **JSON_MERGE_PATCH()**：丢弃重复键的所有值，仅保留最后一个





------



> **注意**

> JSON_MERGE_PRESERVE() 与旧版本 MySQL 中的 JSON_MERGE() 功能相同（8.0.3 起更名）。

> JSON_MERGE() 仍作为 JSON_MERGE_PRESERVE() 的别名存在，但已废弃，未来版本可能移除。



------





### **数组合并**





- **JSON_MERGE_PRESERVE()**：将后续数组拼接到第一个数组的末尾
- **JSON_MERGE_PATCH()**：将每个参数视为仅包含一个元素的数组（索引为 0），然后应用**最后一个值获胜**的规则



```
SELECT
  JSON_MERGE_PRESERVE('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Preserve,
  JSON_MERGE_PATCH('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Patch\G

-- Preserve: [1, 2, "a", "b", "c", true, false]
-- Patch:    [true, false]
```



------





### **对象合并**





- **JSON_MERGE_PRESERVE()**：对于具有相同键的对象，将它们的所有唯一值组合成一个数组，作为该键的值
- **JSON_MERGE_PATCH()**：对于相同键，仅保留最后一个值（从左到右扫描）



```
SELECT
  JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Preserve,
  JSON_MERGE_PATCH('{"a": 3, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Patch\G

-- Preserve: {"a": [1, 4], "b": 2, "c": [3, 5], "d": 3}
-- Patch:    {"a": 4, "b": 2, "c": 5, "d": 3}
```



------





### **自动封装（Autowrapping）**





在需要数组的上下文中，如果值不是数组，会自动用方括号 [ ] 包裹，将其转换为数组。



- **JSON_MERGE_PRESERVE()**：保留所有值
- **JSON_MERGE_PATCH()**：仅保留最后一个值



```
SELECT
  JSON_MERGE_PRESERVE('1', '2') AS Preserve,
  JSON_MERGE_PATCH('1', '2') AS Patch\G

-- Preserve: [1, 2]
-- Patch:    2
```



------





### **数组与对象的混合合并**





对象会先自动封装为数组，然后执行合并：



- **JSON_MERGE_PRESERVE()**：保留所有值
- **JSON_MERGE_PATCH()**：最后一个值获胜



```
SELECT
  JSON_MERGE_PRESERVE('[10, 20]', '{"a": "x", "b": "y"}') AS Preserve,
  JSON_MERGE_PATCH('[10, 20]', '{"a": "x", "b": "y"}') AS Patch\G

-- Preserve: [10, 20, {"a": "x", "b": "y"}]
-- Patch:    {"a": "x", "b": "y"}
```



------



你是想让我现在把 **Searching and Modifying JSON Values（搜索与修改 JSON 值）** 也接着翻译吗？这样 13.5 这一节就能完整到路径语法部分。
